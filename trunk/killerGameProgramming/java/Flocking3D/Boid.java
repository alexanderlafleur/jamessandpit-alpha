package Flocking3D;

// Boid.java
// Andrew Davison, April 2005, ad@fivedots.coe.psu.ac.th
// Sirinart Sakarin, March 2003, s4210315@calvin.coe.psu.ac.th

/* A boid is:
 BG --> TG --> Shape3D
 - a BranchGroup so it can be detached
 - a TransformGroup for moving the boid
 - a Shape3D for its shape

 A boid has position and velocity.
 Its default behaviours are to:
 * perch occasionally
 * avoid obstacles
 * stay within the scene volume
 * not move faster than the set maximum speed
 * to apply Reynold's velocity rules for:
 - cohesion
 - separation
 - alignment

 Obstacle avoidance takes precedence over other velocity rules.

 The Reynold's rules are stored in the Boid's behaviour object.
 In general, rules which require an examination of flockmates
 (which are dynmaically changing) are stored in the behaviour.

 Rules which check static things (e.g. obstacles, scene volume)
 are carried out in the boid itself.

 The boid is updated by a call to animateBoid() which can be
 overriden to add extra behaviours. However, the addition of extra
 velocity rules should be done by overriding doVelocityRules().

 A boid may be 'eaten' which causes it to be detached from the scene 
 and removed from its BoidsList
 */

import java.util.ArrayList;

import javax.media.j3d.BoundingSphere;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.vecmath.Color3f;
import javax.vecmath.Point3d;
import javax.vecmath.Point3f;
import javax.vecmath.Vector3f;

public class Boid extends BranchGroup {
    // the boundaries for boid movement in the scene
    private final static int FLOOR_LEN = 20; // should be even

    private final static Point3f MIN_PT = new Point3f(-(float) FLOOR_LEN / 2.0f, 0.05f, -(float) FLOOR_LEN / 2.0f);

    private final static Point3f MAX_PT = new Point3f(FLOOR_LEN / 2.0f, 8.0f, FLOOR_LEN / 2.0f);

    private final static float MAX_SPEED = 0.2f;

    private static final float AVOID_WEIGHT = 0.2f; // scaling for avoidance
    // vel.

    private final static int PERCH_TIME = 5; // how long to perch

    private final static int PERCH_INTERVAL = 100; // how long between perches

    private static final float BOID_RADIUS = 0.3f; // larger than actual radius

    // used for boid's bounding sphere

    // available to subclasses
    protected FlockBehavior beh;

    protected ArrayList velChanges = new ArrayList();

    // stores all the velocity changes generated by the
    // velocity rules at each update
    protected Vector3f boidPos = new Vector3f();

    protected Vector3f boidVel = new Vector3f();

    private TransformGroup boidTG = new TransformGroup();

    private Obstacles obstacles;

    private BoundingSphere bs = new BoundingSphere(); // bounding sphere for
    // boid

    private float maxSpeed;

    private int perchTime = 0;

    private int perchInterval = 0;

    private boolean isPerching = false;

    // used for repeated calculations
    private Vector3f avoidOb = new Vector3f(); // for the obstacle avoidance
    // velocity

    private Transform3D t3d = new Transform3D(); // for storing boid moves

    private Vector3f newVel = new Vector3f(); // for holding the new boid

    // velocity

    public Boid(Color3f boidColour, float velFactor, Obstacles obs, FlockBehavior bh) {
        this.maxSpeed = MAX_SPEED * velFactor; // to vary the maxSpeed
        this.obstacles = obs;
        this.beh = bh;

        this.boidTG.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);
        this.boidTG.setCapability(TransformGroup.ALLOW_TRANSFORM_READ);
        addChild(this.boidTG);

        this.boidPos.set(randPosn(), (float) (Math.random() * 6.0), randPosn());
        this.boidVel.set(randVel(), randVel(), randVel());
        this.bs.setRadius(BOID_RADIUS); // set bounding sphere's radius

        moveBoid();
        this.boidTG.addChild(new BoidShape(boidColour)); // add boid shape to TG
    } // end of Boid()

    private float randPosn()
    // return a float between -FLOOR_LEN/2 and FLOOR_LEN/2
    {
        return (float) (Math.random() * FLOOR_LEN - FLOOR_LEN / 2);
    }

    private float randVel()
    // return a float between -MAX_SPEED/2 and MAX_SPEED/2
    {
        return (float) (Math.random() * MAX_SPEED * 2 - MAX_SPEED);
    }

    private void moveBoid()
    /*
     * Boid movement is a rotation and a translation, which use the current boid velocity and position.
     */
    {
        this.t3d.setIdentity(); // reset t3d
        this.t3d.rotY(Math.atan2(this.boidVel.x, this.boidVel.z)); // rotate around y-axis
        // atan2() handles 0 value input arguments
        this.t3d.setTranslation(this.boidPos);
        this.boidTG.setTransform(this.t3d); // move the TG
    } // end of moveBoid()

    // -------------------------- animateBoid ---------------------
    // called by FlockBehavior and subclasses

    public void animateBoid()
    // top-level method for updating the boid
    {
        if (this.isPerching) {
            if (this.perchTime > 0) {
                this.perchTime--; // perch a while longer
                return; // skip rest of boid update
            } else { // finished perching
                this.isPerching = false;
                this.boidPos.y = 0.1f; // give the boid a push up off the floor
                this.perchInterval = 0;
            }
        }
        // update the boid's vel & posn, but keep within scene bounds
        this.boidVel.set(calcNewVel());
        this.boidPos.add(this.boidVel);
        keepInBounds();
        moveBoid();
    } // end of animateBoid()

    private Vector3f calcNewVel()
    /*
     * Apply the velocity rules, storing the new velocities in the velChanges ArrayList. Then add the velocities together, and limit the total speed to maxSpeed.
     * 
     * The velocity rules are only applied if there are no obstacles -- obstacle avoidance has priority over the velocity rules
     */
    {
        this.velChanges.clear(); // reset ArrayList

        Vector3f v = avoidObstacles(); // check for obstacle avoidance
        if ((v.x == 0.0f) && (v.z == 0.0f)) {
            doVelocityRules(); // then carry out the other velocity rules
        } else {
            this.velChanges.add(v); // else only do obstacle avoidance
        }

        this.newVel.set(this.boidVel); // re-initialise newVel
        for (int i = 0; i < this.velChanges.size(); i++) {
            this.newVel.add((Vector3f) this.velChanges.get(i)); // add vels to newVel
        }

        this.newVel.scale(limitMaxSpeed());
        return this.newVel;
    } // end of calcNewVel()

    protected void doVelocityRules()
    // override this method to add new velocity rules
    {
        Vector3f v1 = this.beh.cohesion(this.boidPos);
        Vector3f v2 = this.beh.separation(this.boidPos);
        Vector3f v3 = this.beh.alignment(this.boidPos, this.boidVel);
        this.velChanges.add(v1);
        this.velChanges.add(v2);
        this.velChanges.add(v3);
    } // end of doVelocityRules()

    private Vector3f avoidObstacles()
    /*
     * The boid avoids obstacles by checking it's bounding sphere against all the obstacles. The avoidance velocity is stored in avoidOb.
     * 
     * We don't bother calculating a real rebound velocity, just move away by some random amount in the x- and z- direction.
     * 
     * We don't handle impacts on the top of obstacles which require a change in the y- direction.
     */
    {
        this.avoidOb.set(0, 0, 0); // reset
        // update the BoundingSphere's position (but its radius stays the same)
        this.bs.setCenter(new Point3d(this.boidPos.x, this.boidPos.y, this.boidPos.z));
        if (this.obstacles.isOverlapping(this.bs)) {
            this.avoidOb.set(-(float) Math.random() * this.boidPos.x, 0.0f, -(float) Math.random() * this.boidPos.z);
            // scale to reduce distance moved away from the obstacle
            this.avoidOb.scale(AVOID_WEIGHT);
        }
        return this.avoidOb;
    } // end of avoidObstacles()

    private float limitMaxSpeed()
    // scale boid speed so no faster than maxSpeed
    {
        float speed = this.boidVel.length();
        if (speed > this.maxSpeed) {
            return this.maxSpeed / speed;
        } else {
            return 1.0f; // no scaling
        }
    } // end of limitMaxSpeed

    private void keepInBounds()
    /*
     * Adjust the boid's position and velocity so it stays within the volume of space defined by MIN_PT and MAX_PT. Also check if perching should be started.
     */
    {
        // check if x part of the boid's position is within the volume
        if (this.boidPos.x > MAX_PT.x) { // beyond max boundary
            this.boidPos.x = MAX_PT.x; // put back at edge
            this.boidVel.x = -Math.abs(this.boidVel.x); // move away from boundary
        } else if (this.boidPos.x < MIN_PT.x) {
            this.boidPos.x = MIN_PT.x;
            this.boidVel.x = Math.abs(this.boidVel.x);
        }

        // check if z part is within the volume
        if (this.boidPos.z > MAX_PT.z) {
            this.boidPos.z = MAX_PT.z;
            this.boidVel.z = -Math.abs(this.boidVel.z);
        } else if (this.boidPos.z < MIN_PT.z) {
            this.boidPos.z = MIN_PT.z;
            this.boidVel.z = Math.abs(this.boidVel.z);
        }

        // check if y part is within the volume
        if (this.boidPos.y > MAX_PT.y) {
            this.boidPos.y = MAX_PT.y;
            this.boidVel.y = -Math.abs(this.boidVel.y);
        } else if (this.boidPos.y < MIN_PT.y) {
            this.boidPos.y = MIN_PT.y;
            this.boidVel.y = Math.abs(this.boidVel.y);
        }

        this.perchInterval++;
        if ((this.perchInterval > PERCH_INTERVAL) && (this.boidPos.y <= MIN_PT.y)) { // let
            // the
            // boid
            // perch
            this.boidPos.y = 0.0f; // set down on the floor
            this.perchTime = PERCH_TIME; // start perching time
            this.isPerching = true;
        }
    } // end of keepInBounds()

    // ------------------------- other public methods -------------------

    public Vector3f getBoidPos() {
        return this.boidPos;
    }

    public Vector3f getBoidVel() {
        return this.boidVel;
    }

} // end of Boid class
